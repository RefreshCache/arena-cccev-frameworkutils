/**********************************************************************
* Description:	TBD
* Created By:   Jason Offutt @ Central Christian Church of the East Valley
* Date Created:	TBD
*
* $Workfile: DictionaryCache.cs $
* $Revision: 1 $ 
* $Header: /trunk/Arena.Custom.Cccev/Arena.Custom.Cccev.FrameworkUtils/BLL/DictionaryCache.cs   1   2009-07-07 11:12:52-07:00   JasonO $
* 
* $Log: /trunk/Arena.Custom.Cccev/Arena.Custom.Cccev.FrameworkUtils/BLL/DictionaryCache.cs $
*  
*  Revision: 1   Date: 2009-07-07 18:12:52Z   User: JasonO 
*  
*  Revision: 3   Date: 2009-07-06 21:46:29Z   User: JasonO 
*  
*  Revision: 2   Date: 2009-07-06 21:12:15Z   User: JasonO 
*  Adding more common interface elements to caching contracts. 
*  
*  Revision: 1   Date: 2009-07-06 18:50:52Z   User: JasonO 
*  Abstracting caching. 
**********************************************************************/

using System.Collections.Generic;
using Arena.Custom.Cccev.FrameworkUtils.Interfaces;

namespace Arena.Custom.Cccev.FrameworkUtils.BLL
{
    public class DictionaryCache : ICachable
    {
        private static volatile DictionaryCache instance;
        private static readonly object SYNC_ROOT = new object();
        private Dictionary<string, object> cache;

        /// <summary>
        /// Singleton implementation to prevent multiple cache Dictionaries from being instantiated.
        /// </summary>
        public static DictionaryCache Instance
        {
            get
            {
                if (instance == null)
                {
                    lock (SYNC_ROOT)
                    {
                        if (instance == null)
                        {
                            instance = new DictionaryCache();
                        }
                    }
                }

                return instance;
            }
        }

        public object Cache
        {
            get
            {
                if (cache == null)
                {
                    cache = new Dictionary<string, object>();
                }

                return cache;
            }
        }

        public int Count
        {
            get { return ((Dictionary<string, object>) Cache).Count; }
        }

        public object Get(string key)
        {
            Dictionary<string, object> dictionary = (Dictionary<string, object>) Cache;
            return dictionary.ContainsKey(key) ? dictionary[key] : null;
        }

        public void Insert(string key, object value)
        {
            Dictionary<string, object> dictionary = (Dictionary<string, object>) Cache;

            if (!dictionary.ContainsKey(key))
            {
                dictionary.Add(key, value);
            }
            else
            {
                dictionary[key] = value;
            }
        }

        public void Remove(string key)
        {
            Dictionary<string, object> dictionary = (Dictionary<string, object>) Cache;

            if (dictionary.ContainsKey(key))
            {
                dictionary.Remove(key);
            }
        }

        private DictionaryCache()
        {
        }
    }
}
